# -*- coding: utf-8 -*-
"""Neural_Network.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XW9AWIc8diAtCOFK362c2Z3w2bh0Up8m
"""

import numpy as np

def sigmoid(x):
  return 1/(1+np.exp(-x))

def derivative_sigmoid(z):
  s = sigmoid(z)
  return s*(1-s)

def ReLU(x):
  return np.maximum(0,x)

def derivative_ReLU(z):
  return np.where(z>0,1,0)

inp_dim = 2
hidden_dim = 4
output_dim = 1
lr = 5e-1
epochs = 2500

x = np.array([[0,0],[0,1],[1,0],[1,1]])
y = np.array([[0],[1],[1],[0]])

W1 = np.random.rand(inp_dim,hidden_dim)
B1 = np.zeros((1,hidden_dim))
W2 = np.random.rand(hidden_dim,output_dim)
B2 = np.zeros((1,output_dim))

for epoch in range(epochs):
  #forward pass
  z1 = np.dot(x,W1) + B1
  a1 = ReLU(z1)
  z2 = np.dot(a1,W2) + B2
  a2 = sigmoid(z2)

  #loss
  loss = np.mean((y-a2)**2)

  #backpropogation

  da2 = (a2 - y)
  dz2 = da2 * derivative_sigmoid(z2)
  dW2 = np.dot(a1.T, dz2)
  dB2 = np.sum(dz2,axis=0,keepdims=True)

  da1 = np.dot(dz2, W2.T)
  dz1 = da1 * derivative_ReLU(z1)
  dW1 = np.dot(x.T, dz1)
  dB1 = np.sum(dz1,axis = 0, keepdims=True)

  #update weights

  W2 -= lr * dW2
  B2 -= lr * dB2
  W1 -= lr * dW1
  B1 -= lr * dB1

  print(f"Epoch {epoch}, Loss: {loss:.4f}")

# Inference function
def predict(x_new):
    z1 = np.dot(x_new, W1) + B1
    a1 = sigmoid(z1)
    z2 = np.dot(a1, W2) + B2
    a2 = sigmoid(z2)
    return a2

x_test = np.array([[0,1]])

y_pred = predict(x_test)

print(f"Prediction for {x_test} is: {y_pred}")
print(f"Output Answer: {int(y_pred > 0.5)}")